/*!
 * \file main.cpp
 * \brief File with definition of Controller and main() function.
*/
#include <iostream>
#include <memory>
#include <random>
#include <thread>
#include <chrono>

#include <model.h>
#include <view.h>

using std::cout, std::endl;


//!  MVC Controller component class 
/*!
 *  \details MVC Controller class
 */
class VectorRedactor_Controller
{
public:
	/*! \brief An enum to identify GUI event types, which are generated by the user */
	enum class GUI_EVENT_TYPE{
		CreateNewDocument,     /**< 1 create new document */
		ImportDocumentFromFile,/**< 2 import document from file */
		ExportDocumentToFile,  /**< 3 export document to file */
		CreatePrimitive,       /**< 4 create a geometric primitive */
		RemovePrimitive,       /**< 5 remove a given geometric primitive */
		EXIT,                  /**< 6 user exited program */
		None                   /**< 7 no GUI event from the user */
	};
public:
   /*! \brief Constructor of the MVC Controller component @see VectorRedactor_Controller class defintion*/
   /*! \details Sets the MVC Model component object member field of the class @see VectorRedactor_Controller*/
   VectorRedactor_Controller(VectorRedactor_Model* _model)
   {
      model = std::unique_ptr<VectorRedactor_Model>(_model);
   }
   /*! \brief Destructor of the MVC Controller component @see VectorRedactor_Controller class defintion*/
   ~VectorRedactor_Controller()
   {
		model.release();
   }
   /*! \brief Launches the application work cycle */
   /*! \details Is continiously checking the incoming GUI events which are being generated by the user.
    *   The result is store in the variables
    *   - current_gui_event_type
    *   - current_create_primitive_type
    *   The period of these continious cheks is 50 ms. It emulates the real delay with which the real
    *   human is able to continiously generate GUI events: click the mouse and type the keyboard (the
    *   delay is cause by some time which is necessary to release the buttons).
    *   The functions:
    *   - GetCurrentGUIEventType()
    *   - GetCurrentCreatePrimitiveType()
    *   - GetIndexOfCurrentActivePrimitive()
    *   - GetNewDocumentName()
    *   emulate the effects which should be provided by the means of any
    *   graphics library used for creating GUI in the real application:
    *   -# GetCurrentGUIEventType()
    *      - returns the type of the curent GUI event generated by the user at that very moment;
    *   -# GetCurrentCreatePrimitiveType()
    *      - if the user has chosen the option to add a graphics primitive to the canvas of the graphics editor,
    *   this function returns the type of the geometric primitive he has chosen;
    *   -# GetIndexOfCurrentActivePrimitive()
    *      - returns the index of the current primitive hovered bu the mouse (current active primitive)
    *   -# GetNewDocumentName()
    *      - returns the full path to the document, which the user has chosen in the File dialog for opening a new document
    */
   void start()
   {
      model->init();
      bool run=true;
      int step=0;
      do
      {	
      	current_gui_event_type = GetCurrentGUIEventType();
      	cout<<"current_gui_event_type="<<(int)current_gui_event_type<<endl;
      	switch (current_gui_event_type)
      	{
      		case GUI_EVENT_TYPE::CreateNewDocument:
      		{
      			string new_document_name = GetNewDocumentName();
        		  model->CreateNewDocument(new_document_name);
        		  break;
        	   }
        	   case GUI_EVENT_TYPE::ImportDocumentFromFile:
      		{
      			string new_document_name = GetNewDocumentName();
        		   model->CreateNewDocument(new_document_name);
        		   break;
        	   }
        	   case GUI_EVENT_TYPE::ExportDocumentToFile:
      		{
      			string new_document_name = GetNewDocumentName();
        		   model->CreateNewDocument(new_document_name);
        		   break;
        	   }
      		case GUI_EVENT_TYPE::CreatePrimitive:
      		{
      			current_create_primitive_type = GetCurrentCreatePrimitiveType();
        		   model->CreatePrimitive( PrimitivesFactory(current_create_primitive_type) );
        		   break;
        	   }
        	   case GUI_EVENT_TYPE::RemovePrimitive:
      		{
      			if(model->GetPrimitivesSize() > 0)
      			{
      				const size_t index = GetIndexOfCurrentActivePrimitive();
        			   model->RemovePrimitive(index);
        		   }
        		   break;
        	   }
        	   case GUI_EVENT_TYPE::EXIT:
      		{
      			cout<<"current_gui_event_type=EXIT"<<endl;
      			run=false;
        		   break;
        	   }
        	   case GUI_EVENT_TYPE::None:
        		   [[fallthrough]];
         }
         step++;
         //emulates the user's actions delay:
         std::this_thread::sleep_for (std::chrono::milliseconds(50));
         cout<<"STEP #"<<step<<endl;
      }
      while(run);
      cout<<"End of start()"<<endl;
   }
private:
   GUI_EVENT_TYPE GetCurrentGUIEventType() const {
   		return static_cast<GUI_EVENT_TYPE>(rand()%5);
   }
   PRIMITIVE_TYPE GetCurrentCreatePrimitiveType() const {
   		return static_cast<PRIMITIVE_TYPE>(rand()%6);
   }
   size_t GetIndexOfCurrentActivePrimitive() const {
   		size_t index=0;
   		if(model->GetPrimitivesSize() > 0) index = rand()%(model->GetPrimitivesSize());
   		else                               index=0;
   		return index;
   }
   string GetNewDocumentName() const {
   		return "Document1.docx";
   }
   std::unique_ptr<VectorRedactor_Model> model;
   GUI_EVENT_TYPE current_gui_event_type;       
   PRIMITIVE_TYPE current_create_primitive_type;
};

/*! \brief program entry point */
int main()
{
	VectorRedactor_Model model;
   VectorRedactor_View view(&model);
   VectorRedactor_Controller controller(&model);
   controller.start();
   cout<<"END OF PROGRAM"<<endl;

	return 0;
}
